module semantics/runtime/store

imports
  semantics/values

signature
  sort aliases
    Store = Map<Int, Object>
  variables
    S : Store

  constructors
    fetch    : Location --> Object
    store    : Location * Object --> Store
    allocate : Object --> Location

rules

  fetch(Location(i)) :: S --> S[i].

  store(Location(i), object) :: S --> { i |--> object, S }.

  allocate(object) --> location :: S
    where fresh => location;
          store(location, object) --> S.

signature
  constructors
    newObject : List(Method) --> Location
    newObject : List(Method) * List(Decl) --> Location

rules

  newObject(methods) --> allocate(initObject(methods)).

  newObject(methods, decls) --> allocate(initObject(methods, decls)).

signature
  constructors
    setField : Location * String * Location --> Store
    updateMethod : List(RMethod) * Name * RTerm --> List(RMethod)

rules

  setField(location@Location(i), name, value) :: S -->
    store(location, Methods(updateMethod(methods, Name(name), Ref(value))))
      where S[i] => Methods(methods).

  updateMethod([RMethod(mname, _, _) | methods], name, body) -->
    [RMethod(name, [], RBody([], body)) | methods]
      where name == mname.
  updateMethod([method@RMethod(mname, _, _) | methods], name, body) -->
    [method | updateMethod(methods, name, body)]
      where name != mname.
